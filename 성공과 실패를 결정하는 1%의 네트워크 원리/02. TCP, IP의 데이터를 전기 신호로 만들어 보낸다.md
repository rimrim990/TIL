# 성공과 실패를 결정하는 1%의 네트워크 원리

## 02. TCP/IP의 데이터를 전기 신호로 만들어 보낸다

**전체적인 흐름 살펴보기**
- OS에 내장된 **네트워크 제어용 소프트웨어**가 브라우저에서 넘긴 메시지를 패킷 속에 저장하고 수신처 등의 제어 정보를 덧붙인다
- 네트워크 제어용 소프트웨어는 패킷을 하드웨어인 **LAN 어댑터**에 전달한다
- LAN 어댑터는 패킷을 전기 신호로 변환하고 **LAN 케이블**에 송출한다

이번 챕터에서는 브라우저가 생성한 데이터를 프로토콜 스택에서 어떻게 처리하는지 알아보자.
- 프로토콜 스택은 OS에 내장된 네트워크 제어용 소프트웨어를 의미한다

### 소켓을 작성한다
**프로토콜 스택**

브라우저와 같이 OS의 네트워크 서비스를 사용하는 애플리케이션들을 네트워크 애플리케이션이라고 한다
- 브라우저 외에도 웹 메일, 웹 서버 등이 존재한다

네트워크 애플리케이션에서 OS의 프로토콜 스택을 직접 호출하지는 않는다
- 네트워크 기능을 제공하는 `Socket` 라이브러리를 사용하여 OS의 프로토콜 스택에 패킷 송, 수신을 의뢰한다
- `Socket` 라이브러리에는 `DNS` 서버의 클라이언트인 `리졸버`가 존재한다

네트워크 애플리케이션에서 데이터를 송, 수신하기 위해서는 일련의 `Socket` 라이브러리 호출이 필요하다. 그중 첫번째가 `socket` 함수를 호출하여 소켓을 생성하는 것이다. 그렇다면 `socket`은 무엇인가?

**소켓은 무엇인가?**
```shell
$ netstat
Active Internet connections
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  172.30.1.24.60684      tc-in-f188.1e100.5228  ESTABLISHED
tcp4       0      0  172.30.1.24.60440      121.53.214.150.https   ESTABLISHED
tcp4       0      0  172.30.1.24.61685      cdn-185-199-111-.https TIME_WAIT
```
- 통신에 필요한 제어 정보를 기록한 메모리 영역을 소켓이라고 볼 수 있다
- 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하며 통신한다
  - 현재의 통신 상태와 통신 상대의 IP 주소와 포트 번호, 응답 여부, 경과 시간 등을 기록
- 애플리케이션은 소켓을 직접 접근하지 않고 `socket` 함수가 반환한 디스크립터를 사용하여 참조한다

### 서버에 접속한다

**서버에 접속한다?**

서버에 접속한다는 것은 통신에 필요한 제어 정보를 주고 받는 과정이라고 볼 수 있다. 구체적인 동작 과정들은 다음과 같다
- 프로토콜 스택에 통신 상대의 IP 주소나 포트 번호를 알린다
- 송, 수신 데이터를 일시적으로 저장하기 위한 버퍼 메모리를 확보한다
- 통신 상대와 패킷의 시작 시퀀스 번호와 버퍼 윈도우의 크기를 주고 주고 받는다

```
socket.connect(sock, 8.8.8.8:8080);
```
- `Socket` 라이브러리의 `connect` 메서드를 호출하여 연결을 생성할 수 있다
- 한 번 생성된 연결은 `close`를 호출하여 종료하기 전까지 지속된다

### 데이터를 송, 수신한다
**프로토콜 스택에 HTTP 요청 메시지 전달하기**

브라우저는 데이터 송, 수신 기능이 없기 때문에 작성한 HTTP 요청 메시지를 프로토콜 스택에 전달하여 네트워크 전송을 위임한다
- 프로토콜 스택은 전달받은 데이터를 바로 전송하지는 않는다
- 프로토콜 스택이 운반할 수 있는 데이터의 최대 길이인 `MSS`만큼 데이터가 쌓이길 기다린다
- 내부 타이머로 경과 시간을 측정하고, 일정 시간이 지나면 데이터가 충분히 쌓이지 않아도 그냥 전송한다
- 애플리케이션 측에서 데이터가 버퍼에 쌓이지 않고 바로 전송되도록 지정할 수도 있다

**데이터 송신하기**

프로토콜 스택은 브라우저로부터 전달받은 데이터를 송신해야 한다. 그런데 데이터의 크기가 너무 커 `MSS`를 초과하면 `MSS` 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신한다
- 상대방은 데이터를 수신하면 잘 받았다는 의미로 `ACK`번호를 전송한다
- `ACK` 패킷은 마지막으로 받은 데이터 시퀀스 번호의 다음 번호를 전송한다

상대방으로부터 `ACK`번호가 돌아오지 않으면 데이터를 재전송해야 한다
- 패킷 재전송을 위해 데이터를 버퍼 메모리에 임시 보관해 놓는다
- `TCP` 계층에서 네트워크 오류로부터 회복해주기 때문에 LAN 어댑터나 라우터는 모두 회복 조치를 취하지 않는다

패킷을 하나보내고 다시 `ACK`를 기다리는 것은 네트워크 사용량이 적어 비효율적이다. 따라서 윈도우 방식을 사용하여 `ACK`가 도착하지 않아도 여러 개의 패킷을 연속해서 보내도록 한다
- 여러 개의 패킷을 한 번에 보내면 수신측의 버퍼가 넘칠 수도 있다. 수신측이 분할된 패킷을 연결하여 데이터를 복원한 후 애플리케이션에 전달해야 하기 때문에 지연 시간이 발생하기 때문이다
- 패킷이 버퍼 크기를 초과하지 않도록 수신측은 버퍼 크기에 변화가 생기면 `TCP 헤더`의 윈도우 필드에 이를 통지한다

### 서버에서 연결을 끊어 소켓을 말소한다

데이터 전송이 완료되면 `Socket.close`를 호출하여 생성했던 연결을 종료해야 한다
- 연결 과정에서 할당받았던 자원들을 다시 반환한다
- `close`를 호출하면 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다

소켓은 연결이 완전히 종료되고 일정 시간이 지난 후에 말소해야 한다.
- 한 방향에서의 연결이 종료된 후 소켓을 말소하면 포트번호가 해제되고, 다른 소켓애 기존 포트 번호가 할당될 수 있다
- 예를 들어, 도중에 패킷이 유실되어 서버에서 `FIN`을 다시 보낸다면 이는 의도치 않게 새로운 소켓에 전송되어 오작동을 일으킬 수 있다

### IP와 이더넷의 패킷 송, 수신 동작

**중계 장치가 패킷을 전달한다**

패킷 중계 장치에는 `라우터`와 `허브`가 존재한다
- 라우터가 `IP 주소`로 목적지를 확인하여 다음 라우터로 패킷을 전달한다
- 허브가 `MAC 주소`를 기반으로 서브넷 안에서 패킷을 운반하여 다음 라우터에 전달한다

```shell
$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         ip-172-31-16-1. 0.0.0.0         UG    100    0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
ip-172-31-0-2.e ip-172-31-16-1. 255.255.255.255 UGH   100    0        0 eth0
```
- `route` 명령어를 실행하여 호스트 컴퓨터의 라우팅 테이블을 조회하였다
- `Destination`을 목적지를 의미하고 `Gateway`는 해당 목적지로 패킷을 중계해줄 라우터이다. 
`Iface`는 `Gateway`로 패킷을 전달하기 위해 패킷을 송출할 네트워크 인터페이스이다

송신자로부터 중계 장치를 거쳐 패킷을 전달하기 위한 과정은 아래와 같다
- 수신자의 IP 주소로부터 네트워크 인터페이스와 게이트 웨이를 결정한다
- 게이트 웨이 IP 주소로부터 `ARP`로 맥 주소를 알아낸다
- `MAC` 헤더에 게이트 웨이의 맥 주소를 기록한다
- 네트워크 인터페이스를 통해 패킷을 전송하면 연결된 허브가 `MAC` 주소를 기반으로 라우터까지 패킷을 전달한다
- 허브를 거쳐 라우터로 패킷이 도착한다. 일련의 과정을 반복하여 수신자에게 패킷이 도착한다

**ARP 프로토콜**

앞서 패킷 전달 과저에서 `ARP`를 언급했었다. `ARP`는 IP 주소로부터 MAC 주소를 알아내기 위한 프로토콜이다. ARP 동작 과정은 다음과 같다
- 브로드 캐스팅을 통해 연결된 모든 기기에 IP 주소에 해당하는 기기를 찾는 메시지를 전송한다
- IP 주소에 해당하는 기기는 메시지를 받으면 자신의 MAC 주소를 반환한다
- IP 주소에 해당하지 않는 기기는 메시지를 버린다

```shell
$ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
ip-172-17-0-2.ec2.inter  ether   02:42:ac:11:00:02   C                     docker0
ip-172-31-16-1.ec2.inte  ether   0a:12:70:48:52:e9   C                     eth0
```
- `arp` 명령어로 `ARP 캐시`를 조회할 수 있다
- 매번 동일 IP 주소에 대해 `ARP`를 실행하는 것은 비효율적이므로 한 번 실행하면 일정 시간 동안 캐싱해놓는다

**LAN 어댑터 송, 수신 과정**

프로토콜 스택은 패킷을 `LAN` 어댑터에 전송한다. `LAN` 어댑터는 전달받은 패킷을 디지털 데이터에서 전기나 빛과 같은 신호로 변환하고, 이를 물리적인 케이블을 통해 전송한다
- 전송된 신호가 케이블을 타고 흘러가 허브나 라우터 등의 중계 장치에 전달된다
- 수신측의 `LAN 어댑터`는 전달받은 신호를 다시 디지털 데이터로 변환한다

수신측의 `LAN` 어댑터는 허브를 통해 신호를 전달받는다
- `LAN` 어댑터는 신호를 디지털 데이터로 변환하고 `FCS` 값을 비교하여 값이 일치하지 않으면 패킷을 폐기한다
- `LAN` 어댑터는 패킷의 `MAC` 주소를 비교하여 자신에게 온 것이 아니면 폐기하고 일치하면 버퍼 메모리에 저장한다

`LAN 어댑터`는 버퍼 메모리에 패킷이 저장되면 패킷을 수신한 사실을 호스트에 알려야 하는데, 이때 `인터럽트` 방식을 사용한다
- `LAN 어댑터`가 인터럽트용 신호선에 신호를 보내면 연결된 `CPU`가 신호를 받는다
- `CPU`는 신호를 받으면 실행하던 작업을 일시 중단하고 인터럽트 번호에 해당하는 인터럽트 처리 루틴을 실행한다
- 인터럽트 처리 루틴으로는 LAN 드라이버가 호출되며, `LAN 어댑터`의 버퍼 메모리에서 패킷을 가져와 프로토콜 스택에 건네준다
- `IP`는 패킷을 수신한 `LAN 어댑터`에 할당된 IP 주소와 패킷 헤더에 기록된 주소 값을 비교하여 일치하지 않으면 폐기한다

### UDP 프로토콜을 이용한 송, 수신 동작

**UDP 프로토콜의 동작**
- `UDP`는 접속이나 연결 끊기 단계가 없다
- `UDP`는 패킷이 유실되어도 복구 작업을 수행하지 않는다

**UDP 사용 예시**
- 실시간 동영상 스트리밍이나 음성 데이터는 일부가 손실되어도 치명적인 문제가 되지 않는다
- 또한 데이터를 복구하여도 이미 일정 시간이 지나 재생 타이밍이 지나 데이터를 사용할 수 없다
- 따라서 연결 과정이나 재전송이 없는 `UDP`을 사용하는 것이 효율적이다

