# TIL - 2023.11.29 (수)

## 라우팅 알고리즘

**중앙 집약형 알고리즘**
- **전체 네트워크 토폴로지**에 대한 정보를 갖고 최소 비용 경로를 계산한다
- 네트워크에 속한 모든 노드들과 링크들의 정보를 미리 알고 있어야 한다
- ex. `link-state` 알고리즘

**분산형 알고리즘**
- 분산된 라우터에서 반복적으로 최소 비용 경로를 계산한다
- 노드들은 전체 네트워크에 대한 정보는 모르지만 **물리적으로 연결된 링크들의 비용**은 알고 있다
- 이웃 노드와 **반복적으로 비용 정보를 교환**하고 계산하면서 경로 정보를 알아낸다
- ex. `distance vector` 알고리즘

### Link State 라우팅 알고리즘

네트워크 토폴로지와 모든 링크 비용을 알고 있어야 한다
- 네트워크에 속한 다른 노드들에게 링크 비용을 브로드캐스트한다
- 모든 노드들은 동일한 네트워크 정보를 갖게 된다
- 모든 노드들은 LS 알고리즘 수행 후 동일한 최단 경로 정보를 갖게 된다

LS 알고리즘은 최소 비용 경로를 계산하기 위해 **다익스트라 알고리즘**을 사용한다.
예를 들어 노드 u 에서의 최소 비용 경로를 link-state 알고리즘을 사용해 다음과 같이 계산하였다.

| step | N`         | D(v), p(v) | D(w), p(w) | D(x), p(x) |
|------|------------|-----------|------------|------------|
| 0    | u          | 2, u      | x          | x          |
| 1    | u, v       |           | 4, v       | x          |
| 2    | u, v, w    |           |            | 5, w       |
| 3    | u, v, w, x |           |            |            |

- 노드 u 에서 시작하는 최소 비용 경로를 모든 노드에 대해 계산하였다
- 모든 노드는 최소 비용 경로를 만드는 선행 노드 정보를 보유하고 있음

LS 알고리즘을 사용해 만든 비용 테이블을 아래와 같은 **라우팅 테이블로 변환**할 수 있다.

| 목적지 | 링크     |
|-----|--------|
| v   | (u, v) |
| w   | (u, v) |
| x   | (u, v) |

**진동(oscillations) 문제**
- 트래픽양을 링크 비용으로 설정하고 link-state 알고리즘을 수행한다
- link-state 알고리즘이 다시 수행되어 최단 경로가 새로 선택되는데, 모든 노드가 해당 경로로 트래픽을 보내 혼잡 상황이 된다
- link-state 알고리즘이 다시 수행될 때마다 방향을 바꿔가며 방황하게 된다

### Distance Vector 라우팅 알고리즘

각 노드는 직접적으로 연결된 노드하고 정보를 교환한다.
- 경로 비용을 계산한 후 이웃 노드에 전달한다
- 더이상 이웃 노드와 교환할 정보가 없을 때까지 반복적으로 수행한다

LS 알고리즘은 최소 비용 경로를 계산하기 위해 **벨만-포드 알고리즘**을 사용한다.
- 벨만-포드 식을 사용해 최소 비용을 계산한다
- x 에서 y 로 가는 모든 최소 비용 dx(y) = min(c(x, v) +  dv(y)) 이다. (v는 x의 이웃 노드)
- x가 이웃 노드 w의 distance vector를 전달받으면 벨만-포드 식을 사용해 distance-vector를 갱신한다
- x의 distance vector가 변하면 이를 이웃 노드에 전달한다

**count to infinity 문제**
- 링크 코스트가 감소하면 노드 간에 빠르게 전파된다
- 반면에 링크 코스트의 증가는 느리게 전파된다

예를 들어, 다음과 같은 상황을 가정해보자. y에서 x로 가는 경로 비용이 4에서 60으로 증가하였다.

<img width="400" src="https://github.com/rimrim990/TIL/assets/62409503/ac358b6e-3132-4150-9337-34f612bc93c6">

- y는 z에서 x로 가는 최소 경로의 비용이 5인 것을 알기 때문에, x로의 최소 비용을 6으로 갱신하고 이웃 노드에 전달한다
- z는 y에서 x로 가는 경로 비용이 수정되었기 때문에 z에서 x로 가는 최소 비용을 7로 갱신하고 이웃 노드에 전달한다
- y는 다시 비용을 증가시키는데, 이를 y -> x 비용이 51이 될 때까지 반복한다


