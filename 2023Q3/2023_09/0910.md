# TIL - 2023.09.10 (일)
## 스프링 기본키 생성 전략

### 서문
스프링 데이터 JPA 를 사용할 때 기본키 생성 전략에는 다양한 방법이 존재했다.

각 생성 전략이 어떤 방식으로 동작하는지 알아보자.

### 기본키 생성 전략
스프링 데이터 JPA 에서 `@GeneratedValue`로 기본키 자동 생성을 설정한다면 기본키 생성 전략을 선정해야 한다.
기본 설정은 `AUTO`이다

스프링 데이터 JPA 에서 제공하는 기본키 생성 전략은 다음과 같다
- `AUTO`
- `IDENTITY`
- `SEQUENACE`
- `TABLE`

### AUTO
데이터베이스 방언에 따라 키 생성 전략을 설정한다

### IDENTITY
**테이블 생성**

- `IDENTITY` 전략은 데이터베이스의 자동 증가 컬럼에 위임하여 키 값을 생성한다
```
// h2
Hibernate: create table identity_member (id bigint generated by default as identity, primary key (id))
```

**INSERT**
- `IDENTITY`방식으로 설정된 경우 `persist`를 수행한 즉시 `INSERT` 쿼리를 전송하며 영속성 컨텍스트가 지원하는 쓰기 지연이 적용되지 않는다
  - DBMS 에서 키 값을 생성하기 때문에, `INSERT`가 수행되어야 엔티티의 키 값을 알 수 있음
  - 영속성 컨텍스트에서는 키 값으로 엔티티를 관리하기 때문에, 엔티티를 생성하면 반드시 키 값이 할당되어 있어야 한다
```
----INSERT----
Hibernate: insert into identity_member (id) values (default)
----SELECT----
```
- `persist`를 호출한 즉시 쿼리를 전송했다
  - `INSERT`쿼리를 전송한 후에 `SELECT`를 수행했다

### SEQUENCE
**테이블 생성**

- `SEQUENCE` 전략은 데이터베이스의 시퀀스 오브젝트를 사용하여 키 값을 생성한다
```
// h2
Hibernate: create sequence sequence_member_seq start with 1 increment by 50
Hibernate: create table sequence_member (id bigint not null, primary key (id))
```
- 시퀀스 전략이 적용된 테이블 생성 시 시퀀스 오브젝트를 함께 생성한다
  - 시퀀스 값은 1부터 시작한다

**INSERT**

```java
Hibernate: select next value for sequence_member_seq
Hibernate: insert into sequence_member (id) values (?)
```
- DB에 쿼리를 보내 테이블에 사용할 시퀀스 값을 먼저 가져온다
- 가져온 시퀀스 값을 기본 키로 설정하여 `INSERT`쿼리를 호출한다

**allocationSize**
- 시퀀스 전략을 사용하면 데이터베이스로부터 키 값을 미리 가져와아한다
  - 아이덴티티 전략과 마찬가지로 영속성 컨텍스트에서 관리하기 위해서 미리 쿼리를 가져와야 함
  - 따라서 `flush`가 수행되기 전에 미리 `SELECT` 쿼리를 날려 키 값 가져옴
- 그러나 매번 엔티티를 영속화하기 위해 시퀀스 `SELECT` 쿼리를 호출하는 것은 비효율적일 수 있다
  - 매번 네트워크를 통해 쿼리 전송
- 따라서 `allocationSize` 설정을 통해 시퀀스 값을 한 번에 여러 개씩 가져올 수 있다
  - 기본 값은 50

```java
@Entity
public class SequenceMember {

    @Id
    @SequenceGenerator(name = "member_seq", allocationSize = 10)
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;
}
```
- 50개의 시퀀스를 미리 할당해 메모리에 가져온 후, 하나씩 사용한다
- 데이터베이스 시퀀스는 51로 설정된다

```java
Hibernate: select next value for sequence_member_seq
----FIRST PERSISTED-----
Hibernate: select next value for sequence_member_seq

----SECOND PERSISTED CALLED-----
----THIRD PERSISTED CALLED-----
----FOURTH PERSISTED CALLED-----
Hibernate: insert into sequence_member (id) values (?)
Hibernate: insert into sequence_member (id) values (?)
Hibernate: insert into sequence_member (id) values (?)
Hibernate: insert into sequence_member (id) values (?)
```
- 처음에 보낸 요청은 시퀀스 값을 가져오기 위해 `INSERT`가 호출되자마자 `SELECT`쿼리를 호출한다
- 미리 여러 개의 시퀀스 값을 가져왔기 때문에 이후의 `persist`요청들은 메모리에 저장된 시퀀스 값을 사용한다
- 영속성 컨텍스트가 `flush` 될 때 쓰기 지연으로 `INSERT` 쿼리들을 전송한다

```java
Hibernate: insert into sequence_member (id) values (?) // 51
Hibernate: insert into sequence_member (id) values (?) // 101
Hibernate: insert into sequence_member (id) values (?) // 151
```
- 네이티브 쿼리를 호출하여 시퀀스 값을 조회해보았다
- 조회 쿼리가 실행될 때마다 시퀀스 오브젝트의 값이 기본 설정인 50씩 증가한다
- 메모리에 시퀀스 값을 미리 가져온 상태에서 어플리케이션을 내려 메모리가 날라간다면, 시퀀스에 구멍이 생길 수 있다

### Table
**테이블 생성**
- 키 생성을 위한 테이블을 만들어 시퀀스 전략처럼 사용한다
```java
Hibernate: create table hibernate_sequences (next_val bigint, sequence_name varchar(255) not null, primary key (sequence_name))
Hibernate: insert into hibernate_sequences(sequence_name, next_val) values ('default',0)
Hibernate: create table table_member (id bigint not null, primary key (id))
```
- 시퀀스 전략에서는 엔티티 전용 시퀀스 오브젝트를 사용했지만, 테이블 전략에서는 모든 테이블이 공유하는 키 테이블을 생성한다
  - 엔티티 테이블 이름을 pk로 하여 구분

**INSERT**
```java
Hibernate: select tbl.next_val from hibernate_sequences tbl where tbl.sequence_name=? for update
Hibernate: update hibernate_sequences set next_val=?  where next_val=? and sequence_name=?
Hibernate: insert into table_member (id) values (?)
```
- 시퀀스 오브젝트와 마찬가지로 미리 키 값을 가져온다
  - 테이블에 저장된 키 값을 갱신하기 위해 쓰기 락 걺

**allocationSize**
```java
Hibernate: select tbl.next_val from hibernate_sequences tbl where tbl.sequence_name=? for update
Hibernate: update hibernate_sequences set next_val=?  where next_val=? and sequence_name=?
----FIRST PERSISTED CALLED-----
Hibernate: select tbl.next_val from hibernate_sequences tbl where tbl.sequence_name=? for update
Hibernate: update hibernate_sequences set next_val=?  where next_val=? and sequence_name=?
        
Hibernate: insert into table_member (id) values (?)
Hibernate: insert into table_member (id) values (?)
----SECOND PERSISTED CALLED-----
----THIRD PERSISTED CALLED-----
----FOURTH PERSISTED CALLED-----
Hibernate: insert into table_member (id) values (?)
Hibernate: insert into table_member (id) values (?)
```
- 시퀀스 오브젝트와 마찬가지로 `allocationValue`를 설정하여 한 번에 여러 개의 값씩 업데이트하도록 최적화하였다
- 처음 전송된 쿼리로 키 값을 초기화하고, 두 번째 보내진 쿼리로 값을 50 증가시킨다
  - `SELECT`로 조회 시 마지막으로 사용된 키 값을 조회
- 예상과 다르게 시퀀스 전략과 테이블 전략에서 `SELECT`쿼리가 두 번 호출되고 있다.. 🥸
  - 왜일까..